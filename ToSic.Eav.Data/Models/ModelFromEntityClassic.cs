using System.Runtime.CompilerServices;

namespace ToSic.Eav.Models;


/// <summary>
/// BETA / WIP: Base class for **plain** data models and can be used in Razor Components.
/// It wraps an <see cref="IEntity"/> and provides a simple way to access the data.
/// </summary>
/// <example>
///
/// Usage ca. like this:
///
/// 1. A custom data model in `AppCode.Data` which inherits from this class (usually generated by 2sxc Copilot)
/// 2. Razor code which uses it to convert typed items into this custom data model
/// 
/// Example trivial custom **plain** data model:
/// 
/// ```c#
/// namespace AppCode.Data
/// {
///   class MyPerson : DataModel
///   {
///     public int Id => Entity.EntityId;
///     public string Name => Entity.Get&lt;string&gt; ("Name");
///   }
/// }
/// ```
///
/// Example usage in Razor:
///
/// ```razor#
/// @inherits Custom.Hybrid.RazorTyped
/// @using AppCode.Data
/// @{
///   var person = As&lt;MyPerson&gt;(MyItem);
/// }
/// <span>@person.Name</span>
/// ```
/// </example>
/// <remarks>
/// This is much lighter than the [](xref:Custom.Data.CustomItem) which also wraps data, as it doesn't have any predefined properties and doesn't have the <see cref="ITypedItem"/> APIs.
/// 
/// History
/// 
/// - Released in v19.01 (BETA)
/// - Stabilizing in v21 (now first class citizen, part of ToSic.Eav.Models)
/// </remarks>
[InternalApi_DoNotUse_MayChangeWithoutNotice("Still beta, name may change")]
public abstract partial class ModelFromEntityClassic: IModelFromEntity, IModelSetup<IEntity>, ICanBeEntity
{
    #region Explicit Interfaces for internal use - Setup, etc.

    public bool SetupModel(IEntity? source)
    {
        Entity = source!;
        return true;
    }

    //void IDataWrapperNeedingFactory<IEntity>.Setup(IEntity source, IModelFactory modelFactory)
    //{
    //    _entity = source;
    //    _modelFactory = modelFactory;
    //}

    //private IModelFactory _modelFactory = null!;

    /// <summary>
    /// This is necessary so the object can be used in places where an IEntity is expected,
    /// like toolbars.
    ///
    /// It's an explicit interface implementation, so that the object itself doesn't broadcast this.
    /// </summary>
    [PrivateApi]
    [ShowApiWhenReleased(ShowApiMode.Never)]
    IEntity ICanBeEntity.Entity => Entity;

    #endregion

    /// <summary>
    /// The underlying entity - for inheriting classes to access.
    /// </summary>
    /// <remarks>
    /// * this property is protected, not public, as it should only be used internally.
    /// * this also prevents it from being serialized in JSON, which is good.
    /// * it uses an unusual name `_entity` to avoid naming conflicts with properties generated in inheriting classes.
    /// </remarks>
#pragma warning disable IDE1006
    // ReSharper disable once InconsistentNaming
    protected internal IEntity Entity { get; private set; } = null!;
#pragma warning restore IDE1006

    /// <summary>
    /// Override ToString to give more information about the current object
    /// </summary>
    public override string ToString() 
        => $"{nameof(ModelFromEntityClassic)} Data Model {GetType().FullName} " + (Entity == null! ? "without backing data (null)" : $"for id:{Entity.EntityId} ({Entity})");


    #region GetThis

    /// <summary>
    /// Get a value from the underlying entity, whose name matches the property requesting this.
    /// So if your C# property is called `Birthday` it will also get the field `Birthday` in the entity.
    /// </summary>
    /// <typeparam name="T">Optional type, usually auto-detected because of the `fallback` value</typeparam>
    /// <param name="fallback">Value to provide if nothing was found - required</param>
    /// <param name="propertyName">The property name - will be autofill by the compiler</param>
    /// <returns>The typed value</returns>
    [return: NotNullIfNotNull(nameof(fallback))]
    protected T? GetThis<T>(T? fallback, [CallerMemberName] string? propertyName = default)
        => Entity == null!
            ? fallback
            : Entity.Get(propertyName!, fallback: fallback);


    #endregion

}