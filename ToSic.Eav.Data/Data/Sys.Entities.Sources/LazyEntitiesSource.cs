using System.Collections;
using ToSic.Eav.Data.Entities.Sys.Lists;
using ToSic.Eav.Data.Relationships.Sys;
using ToSic.Sys.Caching;

namespace ToSic.Eav.Data.Entities.Sys.Sources;

/// <summary>
/// Delivers entities which are needed. <br/>
/// It's lazy, because on initialization it only knows the Ids (int/guid) of the items to pick up,
/// and only retrieves them when needed. <br/>
/// - Once retrieved, it will cache the result, until the up-stream reports changes.
/// - An additional optimization: in special cases where we just need the IDs for saving,
///   it won't actually query the cache if the IDs are already known.
/// </summary>
[PrivateApi("this is just fyi")]
[ShowApiWhenReleased(ShowApiMode.Never)]
public class LazyEntitiesSource : IEnumerable<IEntity?>, ICacheDependent, IRelatedEntitiesValue
{
    /// <summary>
    /// Initializes a new instance of the EntityRelationship class.
    /// </summary>
    /// <param name="allEntities">DataSource to retrieve child entities</param>
    /// <param name="identifiers">List of IDs to initialize with</param>
    [PrivateApi]
    internal LazyEntitiesSource(IEntitiesSource? allEntities, IEnumerable identifiers)
    {
        _lookupList = allEntities;
        switch (identifiers)
        {
            case null:
                PresetIds = [];
                break;
            case List<int?> intList:
                PresetIds = intList;
                break;
            case ICollection<int?> intCollection:
                PresetIds = intCollection;
                break;
            case List<Guid?> guids:
                PresetGuids = guids;
                break;
            case ICollection<Guid?> guidCollection:
                PresetGuids = guidCollection;
                break;
        }

        // Do some error checking to avoid late nasty problems
        if (PresetIds == null && PresetGuids == null)
            throw new("relationship identifiers must be int? or guid?, anything else won't work");
        if (PresetIds != null && PresetGuids != null)
            throw new("relationship identifiers must be either int? or guid?, but not both at the same time");
    }

    private readonly IEntitiesSource? _lookupList;

    /// <summary>
    /// The EntityIds - if specified. Otherwise, they MUST be null.
    /// </summary>
    private ICollection<int?>? PresetIds { get; }

    /// <summary>
    /// List of Child EntityIds - int-based. Will use the provided list, or assemble one using entity list generated by guids.
    /// </summary>
    /// <remarks>
    /// Note that only the EntityIds <em>or</em> the Guids should be populated.
    /// Note also that nulls will also be used, since there can be "empty" slots in the relationship.
    /// </remarks>
    [field: AllowNull, MaybeNull]
    internal ICollection<int?> ResolvedEntityIds
        => field ??= (PresetIds ?? this.Select(e => e?.EntityId))
            .ToListOpt();

    /// <summary>
    /// Identifiers of the items in the list. Build with either the Guids or the Ids, depending on what was used.
    /// Special mechanism to get identifiers to DB storage, without loading the entities themselves
    /// </summary>
    public IEnumerable Identifiers => PresetGuids as IEnumerable ?? ResolvedEntityIds;

    public int Count => PresetGuids?.Count ?? PresetIds?.Count ?? -1;

    /// <summary>
    /// List of Child EntityIds - int-based.
    /// </summary>
    /// <remarks>
    /// Note that only the EntityIds <em>or</em> the Guids should be populated.
    /// </remarks>
    private ICollection<Guid?>? PresetGuids { get; }

    //internal ICollection<Guid?> Guids => PresetGuids;


    /// <summary>
    /// Lookup the guids of all relationships
    /// Either because the guids were stored - and are the primary key
    /// or because the IDs were stored, and the guids were then looked up
    /// </summary>
    /// <returns></returns>
    /// <remarks>
    /// This is important for serializing to json, because there we need the guids, 
    /// and the serializer shouldn't have know about the internals of relationship management
    /// </remarks>
    [PrivateApi]
    public ICollection<Guid?> ResolveGuids()
    {
        if (PresetGuids != null)
            return PresetGuids;

        // if we have number-IDs, but no lookup system, we'll have to use this as lookup system
        if (PresetIds is { Count: > 0 } && _lookupList == null) // not set yet
            throw new("trying to resolve guids for this relationship, but can't, because the lookupList is not available");

        return this
            .Select(e => e?.EntityGuid)
            .ToListOpt();
    }





    // todo: unclear when this is actually needed / used? - maybe just for debug?
    [PrivateApi]
    public override string ToString()
        => PresetGuids != null
            ? string.Join(",", PresetGuids)
            : PresetIds != null
                ? string.Join(",", PresetIds)
                : string.Empty;

    [PrivateApi]
    public IEnumerator<IEntity?> GetEnumerator()
    {
        // If necessary, initialize first. Note that it will only add Ids which really exist in the source (the source should be the cache)
        if (_entities == null || CacheChanged())
            _entities = LoadEntities();

        return new EntityEnumerator(_entities!);
    }
    private IList<IEntity?>? _entities;

    [PrivateApi]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();


    /// <summary>
    /// Load Entities from IDs or Guids.
    /// Note that null-entity should also be preserved, as they mark "empty" slots in the relationship.
    /// </summary>
    /// <returns></returns>
    private IList<IEntity?> LoadEntities()
    {
        if (_lookupList == null)
        {
            CacheTimestamp = 0;
            return [];
        }

        var result = (PresetGuids != null
                ? PresetGuids
                    .Select(l => l.HasValue
                            ? _lookupList.List.One(l.Value)
                            : null // special: in some cases, the entity cannot be found because it has been deleted or something
                    )
                : PresetIds!
                    .Select(l => l.HasValue
                            ? _lookupList.List.FindRepoId(l.Value)
                            : null // special: in some cases, the entity cannot be found because it has been deleted or something
                    )
            )
            .ToListOpt();

        CacheTimestamp = _lookupList.CacheTimestamp;
        return result;
    }

    /// <inheritdoc />
    public long CacheTimestamp { get; private set; }

    /// <inheritdoc />
    public bool CacheChanged() => _lookupList?.CacheChanged(CacheTimestamp) ?? false;
}